/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

package com.microsoft.graphdataconnect.skillsfinder.service.ingestionmode

import java.time.{ZoneOffset, ZonedDateTime}

import com.microsoft.graphdataconnect.model.admin.ADFTrigger.ADFTrigger
import com.microsoft.graphdataconnect.model.admin.IngestionMode.IngestionMode
import com.microsoft.graphdataconnect.model.admin.IngestionModeSwitchPhase.{IngestionModeSwitchPhase, StartingModeSwitch}
import com.microsoft.graphdataconnect.model.admin.{ADFTrigger, IngestionMode, IngestionModeSwitchPhase}
import com.microsoft.graphdataconnect.skillsfinder.config.MdcUtil
import com.microsoft.graphdataconnect.skillsfinder.exceptions._
import com.microsoft.graphdataconnect.skillsfinder.models.dto.admin.{IngestionModeSwitchState, UserToken}
import com.microsoft.graphdataconnect.skillsfinder.models.response.IngestionModeSwitchStateResponse
import com.microsoft.graphdataconnect.skillsfinder.service.WebSocketService
import com.microsoft.graphdataconnect.skillsfinder.service.adf.ADFService
import org.apache.commons.lang3.exception.ExceptionUtils
import org.slf4j.{Logger, LoggerFactory}
import org.springframework.beans.factory.annotation.{Autowired, Value}
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.{Isolation, Transactional}

import scala.annotation.tailrec
import scala.concurrent.{ExecutionContext, Future}

@Service
class IngestionModeSwitchService(@Autowired val adfService: ADFService,
                                 @Autowired val webSocketService: WebSocketService,
                                 @Autowired val modeSwitchStateService: ModeSwitchStateService,
                                 @Autowired implicit val executionContext: ExecutionContext) {

  private val logger: Logger = LoggerFactory.getLogger(classOf[IngestionModeSwitchService])

  @Value("${adf.polling.interval}")
  var adfPollingInterval: Int = _
  @Value("${adf.polling.attempts.cleanup}")
  var adfCleanupPollingAttempts: Int = _
  @Value("${adf.polling.attempts.pipelines}")
  var adfPipelinesPollingAttempts: Int = _

  def switchToIngestionMode(newIngestionMode: IngestionMode,
                            initialModeSwitchState: IngestionModeSwitchState,
                            correlationId: String)
                           (implicit userToken: UserToken): Unit = {
    val initialModeSwitchPhase: IngestionModeSwitchPhase = initialModeSwitchState.modeSwitchPhase.getOrElse(StartingModeSwitch)
    try {
      MdcUtil.setCorrelationId(correlationId)

      val modeSwitchStartTime = initialModeSwitchState.modeSwitchStartTime
        .getOrElse(throw new IllegalArgumentException("While ingestion mode switch is in progress, mode switch start time should be defined"))

      // stop all running processes (pipelines and triggers)
      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.TriggersStopped.id) {
        adfService.stopAllTriggers()
        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.TriggersStopped))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.TriggersDeleted.id) {
        adfService.deleteAllTriggers()
        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.TriggersDeleted))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.RunningTriggerRunsStopped.id) {
        // Some trigger runs can't get cancelled if the pipelines runs generated by them are InProgress. That is why
        // we also cancel pipelines before trigger runs are cancelled. Then we cancel running pipelines one more time,
        // in case they were concurrently started by trigger runs while cancelling the trigger runs was ongoing
        adfService.cancelRunningPipelines()
        adfService.cancelTriggerRunsFromLastMonth()
        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.RunningTriggerRunsStopped))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.RunningPipelinesStopped.id) {
        adfService.cancelRunningPipelines()
        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.RunningPipelinesStopped))
      }

      var cleanupPipelineRunIdOpt: Option[String] = None
      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.CleanupPipelineStarted.id) {
        // start cleanup pipeline
        cleanupPipelineRunIdOpt = adfService.startCleanupPipeline()
        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.CleanupPipelineStarted))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.CleanupPipelineCompleted.id) {
        if (cleanupPipelineRunIdOpt.isEmpty) {
          cleanupPipelineRunIdOpt = adfService.getCleanupPipelineLatestRunIdInLastMonth()
        }
        cleanupPipelineRunIdOpt match {
          case Some(cleanupPipelineRunId) =>
            logger.info(s"Waiting for cleanup pipeline with run id : $cleanupPipelineRunId to finish")
            waitCleanupPipeline(cleanupPipelineRunId)
          case None => throw new PipelineRunCreationFailedException(ADFService.CLEANUP_PIPELINE_NAME)
        }

        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.CleanupPipelineCompleted))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.IngestionModeUpdatedInAdf.id) {
        //Update gdc_data_ingestion_mode ADF global parameter
        adfService.updateADFIngestionModeGlobalParameter(newIngestionMode)

        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.IngestionModeUpdatedInAdf))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.TriggersRecreated.id) {
        val mostRecentDayInThePast6AM = ADFService.computeMostRecentDayInThePast6AM(modeSwitchStartTime)
        // once gdc_data_ingestion_mode ADF global parameter update is completed
        // create triggers as they were before and notify users about the new Ingestion Mode Switch Phase [TriggersRecreated]
        adfService.createAndStartTriggers(newIngestionMode, mostRecentDayInThePast6AM)

        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.TriggersRecreated))
      }

      // wait until all pipelines runs generated by last week back fill triggers are completed
      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.RecentDataBackfillPipelinesCompleted.id) {
        logger.info("Waiting for relevant pipelines to finish before completing ingestion mode switch")
        waitForRunningPipelines(modeSwitchStartTime)
        changeIngestionModeSwitchState(initialModeSwitchState.cloneWithPhase(IngestionModeSwitchPhase.RecentDataBackfillPipelinesCompleted))
      }

      if (initialModeSwitchPhase.id < IngestionModeSwitchPhase.Completed.id) {
        val mostRecentDayInThePast6AM = ADFService.computeMostRecentDayInThePast6AM(modeSwitchStartTime)
        adfService.createAndStartBackFillFurtherPastEmailTrigger(newIngestionMode, mostRecentDayInThePast6AM)
        val finalState = initialModeSwitchState.copy(
          modeSwitchPhase = Some(IngestionModeSwitchPhase.Completed),
          modeSwitchRequester = None,
          modeSwitchStartTime = None
        )
        changeIngestionModeSwitchState(finalState)
      }
    } catch {
      case e: Throwable =>
        try {
          val lastSuccessfulPhase = modeSwitchStateService.getIngestionModeSwitchPhase
          logger.error(s"Failed to switch to $newIngestionMode starting from phase $initialModeSwitchPhase. Last successfully completed phase was $lastSuccessfulPhase.", e)
        } catch {
          case e: Throwable =>
            logger.error(s"Failed to switch to $newIngestionMode starting from phase $initialModeSwitchPhase.", e)
        }
        val errorState = initialModeSwitchState.copy(
          modeSwitchPhase = Some(IngestionModeSwitchPhase.Error),
          modeSwitchErrorMessage = Some(e.getMessage),
          modeSwitchErrorStackTrace = Some(ExceptionUtils.getStackTrace(e)),
          logsCorrelationId = Some(MdcUtil.getCorrelationId())
        )
        changeIngestionModeSwitchState(errorState)
    } finally {
      MdcUtil.resetCorrelationId()
    }
  }

  private def changeIngestionModeSwitchState(state: IngestionModeSwitchState): Unit = {
    modeSwitchStateService.setIngestionModeSwitchState(state)
    webSocketService.emitNotification(WebSocketService.INGESTION_MODE_SWITCH_STATE_CHANNEL_PATH, IngestionModeSwitchStateResponse(state))
    logger.info(s"Stored in DB and notified listeners about new ingestion mode switch state: $state")
  }

  @tailrec
  private def waitCleanupPipeline(cleanupPipelineRunId: String, attemptsLeft: Int = adfCleanupPollingAttempts)(implicit userToken: UserToken): Unit = {
    val isPipelineRunInProgress = adfService.isPipelineRunInProgress(cleanupPipelineRunId)
    if (isPipelineRunInProgress && attemptsLeft > 0) {
      logger.trace(s"Waiting $adfPollingInterval seconds before checking again the status of pipeline: $cleanupPipelineRunId. Attempts left: $attemptsLeft")
      Thread.sleep(adfPollingInterval * 1000)
      waitCleanupPipeline(cleanupPipelineRunId, attemptsLeft - 1)
    } else if (adfService.isPipelineRunInFailedStatus(cleanupPipelineRunId)) {
      throw new CleanupPipelineFailed(s"Cleanup pipeline run with id $cleanupPipelineRunId failed!")
    }
    else if (attemptsLeft == 0) {
      logger.error("The number of attempts left is now 0, can't wait anymore for Cleanup pipeline to finish. Moving on updating Ingestion Mode")
      throw new ExceededWaitingTimeException(s"Exceeded waiting time for cleanup pipeline run with id $cleanupPipelineRunId")
    }
  }

  @tailrec
  private def waitForRunningPipelines(ingestionModeSwitchStartTime: ZonedDateTime,
                                      attemptsLeft: Int = adfPipelinesPollingAttempts)
                                     (implicit userToken: UserToken): Unit = {
    // start with a pause because triggers may need some time till they start pipelines
    logger.trace(s"Waiting $adfPollingInterval seconds before checking again if there is any pipeline running. Attempts left: $attemptsLeft")
    try {
      Thread.sleep(adfPollingInterval * 1000)
    } catch {
      case _: InterruptedException =>
        logger.warn(s"Failed to wait $adfPollingInterval seconds before checking for pipelines that are in progress due to interruption. Moving on.")
    }

    val employeePipelinesFinished = pipelinesStartedByTriggerFinished(ADFTrigger.EMPLOYEE_PROFILES_PIPELINE_BACKFILL_TRIGGER, ingestionModeSwitchStartTime)
    val emailsPipelinesFinished = pipelinesStartedByTriggerFinished(ADFTrigger.EMAILS_PIPELINE_BACKFILL_PAST_WEEK_TRIGGER, ingestionModeSwitchStartTime)
    val inferredRolesPipelinesFinished = pipelinesStartedByTriggerFinished(ADFTrigger.INFERRED_ROLES_PIPELINE_BACKFILL_TRIGGER, ingestionModeSwitchStartTime)
    val airtablePipelinesFinished = pipelinesStartedByTriggerFinished(ADFTrigger.AIRTABLE_PIPELINE_BACKFILL_TRIGGER, ingestionModeSwitchStartTime)

    if ((!employeePipelinesFinished || !emailsPipelinesFinished || !inferredRolesPipelinesFinished || !airtablePipelinesFinished) && attemptsLeft > 0) {
      waitForRunningPipelines(ingestionModeSwitchStartTime, attemptsLeft - 1)
    } else if ((!employeePipelinesFinished || !emailsPipelinesFinished || !inferredRolesPipelinesFinished || !airtablePipelinesFinished) && attemptsLeft <= 0) {

      logger.error("The number of attempts left is now 0, can't wait anymore for all running pipelines to finish.")
      throw new ExceededWaitingTimeException("Exceeded waiting time for 'last week back fill' pipelines to finish.")
    } else {
      logger.info("All pipeline runs finished.")
    }
  }

  private def pipelinesStartedByTriggerFinished(adfTrigger: ADFTrigger,
                                                ingestionModeSwitchStartTime: ZonedDateTime,
                                                mustFinishSuccessfully: Boolean = true)
                                               (implicit userToken: UserToken): Boolean = {
    //First we get all the pipeline run ids for the pipeline runs started by the trigger
    val pipelineRunIds: List[String] = adfService.getLatestPipelineRunsForTriggerStartingAfterTimestamp(
      adfTrigger.triggerName,
      ingestionModeSwitchStartTime,
      adfTrigger.numOfPipelinesStartedByTrigger)
    // Then we filter to see which of the pipelines are InProgress
    val inProgressPipelinesRunIds = adfService.filterInProgressPipelines(pipelineRunIds, mustFinishSuccessfully)

    pipelineRunIds.size.equals(adfTrigger.numOfPipelinesStartedByTrigger) && inProgressPipelinesRunIds.isEmpty
  }

  @Transactional(isolation = Isolation.SERIALIZABLE)
  def updateIngestionMode(ingestionMode: IngestionMode.IngestionMode, currentUserEmail: String)(implicit userToken: UserToken): IngestionMode = {
    logger.info(s"Updating ingestion mode to: $ingestionMode")

    val ingestionModeSwitchState = modeSwitchStateService.getIngestionModeSwitchState
    val currentModeSwitchPhaseOpt: Option[IngestionModeSwitchPhase] = ingestionModeSwitchState.modeSwitchPhase
    logger.info(s"Current ingestion mode switch phase ${currentModeSwitchPhaseOpt.orNull}   $ingestionMode")

    if (currentModeSwitchPhaseOpt.isEmpty) {
      throw new ServerErrorException("There is no ingestion mode switch phase stored in the database!")
    }

    if (currentModeSwitchPhaseOpt.get != IngestionModeSwitchPhase.Completed &&
      currentModeSwitchPhaseOpt.get != IngestionModeSwitchPhase.Error) {
      throw new InvalidRequestException("Ingestion mode switch is already in progress")
    }

    val currentIngestionModeOpt: Option[IngestionMode] = ingestionModeSwitchState.ingestionMode
    logger.info(s"Current ingestion mode ${currentIngestionModeOpt.get}")
    if (currentIngestionModeOpt.isEmpty) {
      throw new ServerErrorException("There is no ingestion mode value stored in the database!")
    }

    if (currentIngestionModeOpt.get != ingestionMode ||
      (currentIngestionModeOpt.get == ingestionMode && currentModeSwitchPhaseOpt.get == IngestionModeSwitchPhase.Error)) {

      val newIngestionModeSwitchState = IngestionModeSwitchState(
        ingestionMode = Some(ingestionMode),
        modeSwitchPhase = Some(IngestionModeSwitchPhase.StartingModeSwitch),
        modeSwitchPaused = false,
        modeSwitchRequester = Some(currentUserEmail),
        modeSwitchStartTime = Some(ZonedDateTime.now(ZoneOffset.UTC)),
        modeSwitchErrorMessage = None,
        modeSwitchErrorStackTrace = None,
        logsCorrelationId = None
      )

      // update DB and let users know about the new ingestion mode switch state
      changeIngestionModeSwitchState(newIngestionModeSwitchState)

      startAsyncSwitchToIngestionMode(ingestionMode, newIngestionModeSwitchState)

      ingestionMode
    } else {
      throw new IngestionModeSwitchRejectedException(s"Ingestion mode won't be changed because it is already set as $ingestionMode")
    }
  }

  @Transactional(isolation = Isolation.SERIALIZABLE)
  def retryIngestionModeSwitch(currentUserEmail: String)(implicit userToken: UserToken): IngestionMode = {
    logger.info(s"Retrying ingestion mode switch")

    val ingestionModeSwitchState = modeSwitchStateService.getIngestionModeSwitchState
    logger.info(s"Initial ingestion mode switch state on retry: $ingestionModeSwitchState")

    val currentIngestionModeOpt: Option[IngestionMode] = ingestionModeSwitchState.ingestionMode
    val currentModeSwitchPhaseOpt: Option[IngestionModeSwitchPhase] = ingestionModeSwitchState.modeSwitchPhase

    if (currentModeSwitchPhaseOpt.isEmpty || currentModeSwitchPhaseOpt.get != IngestionModeSwitchPhase.Error) {
      throw new InvalidRequestException("Ingestion mode switch can only be retried after if had previously failed!")
    }

    if (currentIngestionModeOpt.isEmpty) {
      throw new ServerErrorException("There is no ingestion mode value stored in the database! Cannot retry ingestion mode switch")
    }

    val newIngestionModeSwitchState = IngestionModeSwitchState(
      ingestionMode = currentIngestionModeOpt,
      modeSwitchPhase = Some(IngestionModeSwitchPhase.StartingModeSwitch), // Resetting phase as we retry from scratch
      modeSwitchPaused = false,
      modeSwitchRequester = Some(currentUserEmail),
      modeSwitchStartTime = Some(ZonedDateTime.now(ZoneOffset.UTC)),
      modeSwitchErrorMessage = None, // Resetting previous error related fields as we retry from scratch
      modeSwitchErrorStackTrace = None,
      logsCorrelationId = None
    )

    // update DB and let users know about the new ingestion mode switch state
    changeIngestionModeSwitchState(newIngestionModeSwitchState)

    startAsyncSwitchToIngestionMode(currentIngestionModeOpt.get, newIngestionModeSwitchState)

    currentIngestionModeOpt.get
  }

  @Transactional(isolation = Isolation.SERIALIZABLE)
  def resumeIngestionModeSwitch(currentUserEmail: String)(implicit userToken: UserToken): IngestionMode = {
    logger.info(s"Resuming ingestion mode switch")

    val ingestionModeSwitchState = modeSwitchStateService.getIngestionModeSwitchState
    logger.info(s"Initial ingestion mode switch state on resume: $ingestionModeSwitchState")

    val currentIngestionModeOpt: Option[IngestionMode] = ingestionModeSwitchState.ingestionMode
    val currentModeSwitchPhaseOpt: Option[IngestionModeSwitchPhase] = ingestionModeSwitchState.modeSwitchPhase

    if (currentModeSwitchPhaseOpt.isEmpty) {
      throw new InvalidRequestException("There is no previous ingestion mode switch phase stored in the database! Cannot resume ingestion mode switch")
    }

    if (currentModeSwitchPhaseOpt.get == IngestionModeSwitchPhase.Error) {
      throw new InvalidRequestException("Ingestion mode switch cannot be resumed after a failure. Retry must be called instead")
    }

    if (!ingestionModeSwitchState.modeSwitchPaused) {
      throw new InvalidRequestException("Ingestion mode switch can only be resumed after a switch had previously been paused (e.g. by an application restart)")
    }

    if (currentIngestionModeOpt.isEmpty) {
      throw new ServerErrorException("There is no ingestion mode value stored in the database! Cannot resume ingestion mode switch")
    }

    if (ingestionModeSwitchState.modeSwitchStartTime.isEmpty) {
      throw new InvalidRequestException("There is no previous ingestion mode switch start time stored in the database! Cannot resume ingestion mode switch")
    }

    // The modeSwitchStartTime is left unchanged from the previous run because we need to check&wait for running ADF pipelines
    // started after the start time. If the pipelines were already created before the application restarted (and the switch
    // was paused), the resetting the start time would impact this check.
    // The only downside is that if the triggers were not already created before app restart, then they will be
    // created with a potentially slightly older time window, based on the initial start time.
    val newIngestionModeSwitchState = ingestionModeSwitchState.copy(
      modeSwitchPaused = false, // Reset the paused flag
      modeSwitchRequester = Some(currentUserEmail)
    )

    // update DB and let users know about the new ingestion mode switch state
    changeIngestionModeSwitchState(newIngestionModeSwitchState)

    startAsyncSwitchToIngestionMode(currentIngestionModeOpt.get, newIngestionModeSwitchState)
    currentIngestionModeOpt.get
  }

  def startAsyncSwitchToIngestionMode(targetIngestionMode: IngestionMode,
                                      initialModeSwitchState: IngestionModeSwitchState)
                                     (implicit userToken: UserToken): Unit = {
    // Since the Future is executed in another thread (other that the one in which the current HTTP request is processed in)
    // we need to explicitly pass the current correlationId (which is thread specific) to that thread
    val correlationId = MdcUtil.getCorrelationId()
    Future { // time consuming tasks - starting a new thread
      switchToIngestionMode(targetIngestionMode, initialModeSwitchState, correlationId)
    }
  }

}
